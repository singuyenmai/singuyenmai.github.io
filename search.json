[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "‚ÄúGood morning!  And in case I don‚Äôt see ya,  good afternoon, good evening, and good night!‚Äù",
    "section": "",
    "text": "‚ÄúGood morning!  And in case I don‚Äôt see ya,  good afternoon, good evening, and good night!‚Äù\n\n\n\n\nHi üëã, I am Si-Nguyen Mai.\nI generate and use computer codes, to understand and engineer life ü¶† üåè.\nWelcome, to my virtual world! üåå"
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html",
    "title": "A chaotic butterfly",
    "section": "",
    "text": "In this blog post, I would like to demonstrate a model introduced by the meteorologist Edward Lorenz in 1963. This model describes the dynamics of atmospheric convection, which, when illustrated from the right perspective, appear visually beautiful in the shape of a butterfly, as you have seen in the preview image. Yet, what is more fascinating about this model is that although the equations are in very simplistic forms, the resulting dynamics are extremely complex. Indeed, the Lorenz model is a typical example for chaotic systems and is the origin of the concept of the butterfly effect. In latter part of the blog, I would also illustrate this concept and show why long-range forcasting can still have limitations even when we already have the exact rules of things.\nTo demonstrate the model, I used Python for solving the equations and also for visualization. I would not talk much about the coding parts, so you would not have to worry if you‚Äôre not very confident with coding. But, all codes were still provided and the code cells are compacted, so that if you want to have a look, then you can still choose to show them."
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html#introduction",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html#introduction",
    "title": "A chaotic butterfly",
    "section": "",
    "text": "In this blog post, I would like to demonstrate a model introduced by the meteorologist Edward Lorenz in 1963. This model describes the dynamics of atmospheric convection, which, when illustrated from the right perspective, appear visually beautiful in the shape of a butterfly, as you have seen in the preview image. Yet, what is more fascinating about this model is that although the equations are in very simplistic forms, the resulting dynamics are extremely complex. Indeed, the Lorenz model is a typical example for chaotic systems and is the origin of the concept of the butterfly effect. In latter part of the blog, I would also illustrate this concept and show why long-range forcasting can still have limitations even when we already have the exact rules of things.\nTo demonstrate the model, I used Python for solving the equations and also for visualization. I would not talk much about the coding parts, so you would not have to worry if you‚Äôre not very confident with coding. But, all codes were still provided and the code cells are compacted, so that if you want to have a look, then you can still choose to show them."
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html#the-model",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html#the-model",
    "title": "A chaotic butterfly",
    "section": "The model",
    "text": "The model\nThe Lorenz system comprises of three dynamic elements, or variables, notated as \\(X\\) (rate of convection), \\(Y\\) (horizontal temperature), and \\(Z\\) (vertical temperature). The dynamics of these variables then are described by a set of ordinary differential equations (ODE). These equations represent the rates of change of the variables, and they are as follows:\n\\[\n\\frac{dX}{dt} = \\sigma (Y - X)\n\\] \\[\n\\frac{dY}{dt} = X (\\rho - Z) - Y\n\\] \\[\n\\frac{dZ}{dt} = X Y - \\beta Z\n\\]\nI would not explain the equations in detail here, but only note that in the equations, \\(\\sigma\\), \\(\\rho\\), and \\(\\beta\\) are constant parameters and under the setting of \\(\\sigma=10\\), \\(\\rho=28\\), and \\(\\beta=8/3\\), we would see ‚Äúthe butterfly‚Äù and all the interesting insights from it."
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html#the-butterfly",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html#the-butterfly",
    "title": "A chaotic butterfly",
    "section": "The butterfly",
    "text": "The butterfly\nTo see exactly how the system state, i.e.¬†the variables, change through time, we will need to solve the ODEs by integrating them. We can do this easily in Python with the odeint function of scipy.integrate package. For it to do the job, we need the following main ingredients:\n\nA function that returns the list of the ODEs\nThe system parameters that we‚Äôre interested in: \\(\\sigma=10\\), \\(\\rho=28\\), and \\(\\beta=8/3\\)\nThe timepoints at which we would like to know the values of the three variables. Here, they are 100,000 timepoints evenly spaced from 0 to 100.\nThe initial condition, which is the system state at the initial timepoint. Here, it is a set of \\(X_{t=0} = 0.1, Y_{t=0}=0.0, Z_{t=0}=0.0\\).\n\n\n\nCode\n# Define the lorenz system\n# X, Y, and Z make up the system state, t is time\n# sigma, rho, beta are the system parameters\ndef lorenz_system(state, t, sigma, rho, beta):\n    \n    # system state depends on three variables: x, y, z\n    X, Y, Z = state\n    \n    # define the three ODEs describing the rates of change of the above three variables\n    dX_dt = sigma * (Y - X)\n    dY_dt = X * (rho - Z) - Y\n    dZ_dt = X * Y - beta * Z\n    \n    # return a list of the ODEs\n    return [dX_dt, dY_dt, dZ_dt]\n\n# Define the system parameters sigma, rho, and beta\nsigma = 10.\nrho   = 28.\nbeta  = 8./3.\n\n# Define the time points to solve for, evenly spaced between the start and end times\nstart_time = 0\nend_time = 100\n\nimport numpy as np\ntime_points = np.linspace(start_time, end_time, end_time*1000)\n\n# Define the initial system state - a list of X, Y, Z values at the initial time point, respectively\ninitial_state = [2., 4., 5.5]\n# initial_state = [0.1, 0., 0.0]\n\n# Solve the ODE system with `odeint`\nfrom scipy.integrate import odeint\n\n# by supplying the `odeint` with \n# 1, the function describing the system of ODEs\n# 2, list of initial system conditions\n# 3, sequence of time points to solve for\n# 4, tuple of system parameters\n# the result is an array of X, Y, and Y value arrays for each time point, with the initial values in the first row\nXYZ = odeint(lorenz_system, initial_state, time_points, args=(sigma, rho, beta))\n\n# extract the individual arrays of X, Y, and Z values\nX = XYZ[:, 0]\nY = XYZ[:, 1]\nZ = XYZ[:, 2]\n\n\nOnce these are supplied to the function, we get the solution which are 3 arrays (vectors) for the values of \\(X\\), \\(Y\\), and \\(Z\\) throughout time. Of course, these arrays have the length of 100,000 for the timepoints that we have set before, corresponding to the 100,000 system states changing throughout time. Now then, with these arrays, we can easily observe the dynamics of the system through some few more visualization steps!\nThe preview image of this blog post is a plot of \\(X\\) against \\(Z\\) values. In other words, it‚Äôs a 2D projection on the X-Z plane. Note that the colors we see represent time. So the change from red, orange, then yellow, to green, then blue illustrates the change of time from 0 to 100 units.\n\n\nCode\n# Packages for visualisation\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Set plot styles, fonts, legends, and math text\nsns.set_style(\"white\")\nfont = {'family': 'sans-serif', 'serif': 'Helvetica',\n        'size': 18}\nplt.rc('font', **font)\nlegnd = {'fontsize': 11, 'handlelength': 1.5}\nplt.rc('legend', **legnd)\n\n# Plotting the butterfly - a \"phase plot\" of X values against Z values\nfig, ax = plt.subplots(figsize=(10, 8))\n\nax.scatter(X, Z, c=time_points, cmap=\"Spectral\", s=5)\n\nignored = plt.axis(\"off\")\nfig.savefig(\"lorenz_butterfly.png\", transparent=True)\n\n\n\n\n\n\n\n\n\nWe could also plot the system states as points in 3D and, again, coloring them by their timepoints. Below, I generated an interactive plot for this, so we could actually view the system entirely and, especially, inspect it from multiple angles. Try to hold your pointer on the image and then turn it around!\n\n\nCode\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.io as pio\n\nfig = px.scatter_3d(x=X, y=Y, z=Z, \n                    color=time_points, color_continuous_scale='Spectral', \n                    width=600, height=600)\n\nfig.update_traces(marker=dict(size=0.8, line_width=0.0))\nfig.update_layout(template=\"plotly_white\", \n                  scene_camera=dict(eye=dict(x = -1., y = 1., z = 0.25)), \n                  scene_aspectratio=dict(x=0.75, y=0.75, z=0.8))\nfig.update_coloraxes(colorbar=dict(lenmode='fraction', len=0.5, title=\"Time\"))\n\n# add the initial state\nfig.add_trace(go.Scatter3d(x=[initial_state[0]], y=[initial_state[1]], z=[initial_state[2]], marker=dict(color='black', size=5.), \n                           mode=\"markers\", hovertext=\"Initial condition\", showlegend=False))\nfig.show()\n\n\n\n                                                \n\n\nNow pay more attention to the colors of the buterfly, we see that the beauty comes from the mix of warm and cold colors in both wings. What does that exactly mean?\nWell, because the change in colors represents the change in time and that the two wings indicate two main regions of system state, this colorful image tells us that as time goes, the system state switchs very frequently back and forth between those two regions. To understand this dynamic clearer, let‚Äôs play the animation I created with Plotly below and follow the movement of the black dot, which indicates the system state.\n\n\nCode\neps = 5\n\nfig = go.Figure(\n    data= [go.Scatter3d(x=X, y=Y, z=Z,\n                     mode=\"lines\",\n                     line=dict(width=2., color=time_points, \n                               colorscale='Spectral', showscale=True, \n                               colorbar=dict(lenmode='fraction', len=0.5, title=\"Time\"))),\n           go.Scatter3d(x=X, y=Y, z=Z,\n                     mode=\"lines\",\n                     line=dict(width=2., color=time_points, \n                               colorscale='Spectral', showscale=True, \n                               colorbar=dict(lenmode='fraction', len=0.5, title=\"Time\")))\n          ],\n    frames=[go.Frame(\n        data=[go.Scatter3d(x=[X[i]], y=[Y[i]], z=[Z[i]], marker=dict(color='black', size=3.), \n                           mode=\"markers\")\n             ])\n            for i in np.round(np.linspace(0, len(time_points)-1, 2000)).astype(int)]\n)\n\ndef frame_args(duration):\n    return {\n            \"frame\": {\"duration\": duration},\n            \"mode\": \"immediate\",\n            \"fromcurrent\": True,\n            \"transition\": {\"duration\": duration},\n            }\n\nfig.update_layout(\n    template=\"plotly_white\", width=600, height=600, \n    margin=dict(l=0.5, r=0.5, t=0.5, b=0.5),\n    showlegend=False,\n    scene = dict(xaxis=dict(range=[min(X)-eps, max(X)+eps], autorange=False, zeroline=False),\n                yaxis=dict(range=[min(Y)-eps, max(Y)+eps], autorange=False, zeroline=False),\n                zaxis=dict(range=[min(Z)-eps, max(Z)+eps], autorange=False, zeroline=False)),\n    scene_camera=dict(eye=dict(x = -1., y = 1., z = 0.25)),\n    scene_aspectratio=dict(x=0.8, y=0.8, z=0.8),\n    updatemenus = [{\"buttons\":[{\n                        \"args\": [None, frame_args(1.)],\n                        \"label\": \"Play\", \n                        \"method\": \"animate\",\n                    },\n                    {\n                        \"args\": [[None], frame_args(0.)],\n                        \"label\": \"Pause\", \n                        \"method\": \"animate\",\n                  }],\n                    \n                \"direction\": \"left\",\n                \"pad\": {\"r\": 10, \"t\": 70},\n                \"type\": \"buttons\",\n                \"x\": 0.1,\n                \"y\": 0.1,\n            }\n         ]\n)\n\nfig.update_geos(resolution=110)\nfig.show()\n\n\n\n                                                \n\n\n Following the change of the system state through time, we can see that the pattern of change seems to repeat itself. At first, the system state circles towards the right wing, yet once it lands on this wing, it circles out. The circling goes on for a while until suddenly, the system switches back to the left wing, which then, again, circles out until it moves back to the right wing. This pattern keeps repeating and can go on infinitely! Another interesting thing about the dynamics is that although the pattern is replicated, the system always takes new paths and never it goes back to an old state. Geometrically, this structure is considered as a fractal."
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html#chaos-determinism",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html#chaos-determinism",
    "title": "A chaotic butterfly",
    "section": "Chaos & Determinism",
    "text": "Chaos & Determinism\nThe ‚Äústrange‚Äù dynamics described above also show chaotic behaviours. To be clearer, the system is chaotic because it never converges to any specific fixed state (aka stable state), but keeps changing over time and the cyles are never exactly the same. To see the chaos of the Lorenz system clearer, let‚Äôs view separately the changes through time of each variable \\(X\\), \\(Y\\), and \\(Z\\).\n\n\nCode\nfig, ax = plt.subplots(figsize=(12, 6), nrows=3, ncols=1, sharex=True)\n\ncolors = ['tab:blue', 'tab:orange', 'tab:green']\nlabels = ['X', 'Y', 'Z']\nfor i in range(3):\n    ax[i].plot(time_points, XYZ[:, i], lw=1, c=colors[i])\n    ax[i].set_ylabel(labels[i], rotation=0, labelpad=30)\n\nignored = ax[2].set_xlabel(\"Time\")\n\n\n\n\n\n\n\n\n\nAs can be seen, all the variables fluctuate wildly over time. They do not converge to any stable state. And, although we see fluctuations, there seems to be no fixed periodic cycle in the dynamics. This, is chaos!\nOn the contrary, an example of a stable system is a population that follows logistic growth (figure below). In this case, the population at first grows exponentially, propbably because the resources are still abundant. However, since resources are limited, the population cannot grow to infinity but is restricted to a limit called carrying capacity. Once the population size reaches this limit, the population experiences no more change and remains stable there. The population level at the carrying capacity, therefore, is referred as a stable state, or stable attractor (it‚Äôs like the population is attracted to grow towards it).\n\n\nCode\ndef logistic_growth(N, t, r, K):\n    dN_dt = r*N*(1 - N/K)\n    return dN_dt\n\nN0 = 2\nts = np.linspace(0, 200, 1000)\nr = 0.06\nK = 70\npop = odeint(logistic_growth, N0, ts, args=(r, K)).flatten()\n\nfig, ax = plt.subplots(figsize=(7,5))\n\nplt.axhline(y=K, color='black', ls='--', lw=1) # carrying capacity\nplt.text(x=650, y=62, s=\"Carrying capacity\", color='grey')\n\nax.plot(pop, lw=4)\n\nplt.rcParams['text.usetex'] = True\n\nax.set(xlabel=r\"Time ($t$)\", ylabel=r\"Population size ($N$)\")\nequation = plt.text(x=350, y=25, s=r'$\\frac{dN} {dt} = rN( 1 - \\frac{N}{K})$', fontsize=30, fontweight='bold', color='tab:blue')\n\nplt.rcParams['text.usetex'] = False\n\n\n\n\n\n\n\n\n\nConsidering one big assumption of the Lorenz model, we may start feel a bit strange about the chaotic behaviours we‚Äôve seen.\nFirst, what the model assumed is that there are certain fixed rules for the changes of atmospheric convection, which, are represented by the ODEs. This assumption is determinism. And in the Lorenz system, those rules are also very simple, However, to what we‚Äôve seen, the system behaviour is extremely complex and the dynamics are chaotic. So all of these tell us that, strangely yet beautifully, chaos can come from determinism and complex dynamics/behaviours can come from just simple rules.\nAnother way to interpret these is that when we observe and study the outside world, although some systems may appear to behave chaotically and their changes over time may seem so complex, there is still a possibility that such systems are actually determined by some fixed, and perhaps simple, rules. This brings lots more hope to our desire to understand the world üòÑ. For me, this interpretation is also special because it is almost the same as the philosophy of the ancient I Ching, or The Book of Changes."
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html#determinism-predictibility",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html#determinism-predictibility",
    "title": "A chaotic butterfly",
    "section": "Determinism & Predictibility",
    "text": "Determinism & Predictibility\nAs chaotic systems do not converge to any fixed stable states, they are sensitive to initial conditions. This means that if we change the initial conditions very slightly different, for instance by an \\(\\epsilon = 10^{-10}\\) in just one variable \\(X\\), then the dynamics will be changed as well. Let‚Äôs take a look at the resulting dynamics.\nComplex dynamics obstruct predictions. It is absolutely certain that if a system is deterministic and defined by a constant set of rules, then we sure can predict its future once we know exactly two things: (1) the rules dictating and (2) the system‚Äôs current or past states. However, even assuming that we already have the (1) condition, it‚Äôs still practically impossible to have perfectly precise measurements for the (2) condition. And this, is a problem that comes with predictibilities of chaotic systems.\n\n\nCode\n# add an eps=10^{-10} to initial X \nepsilon = 10**(-15)\ninitial_state_new = [2. + epsilon, 4., 5.5]\n# initial_state = [0.1, 0., 0.0]\n\n# Solve the ODE system with `odeint`\nfrom scipy.integrate import odeint\nXYZ_new = odeint(lorenz_system, initial_state_new, time_points, args=(sigma, rho, beta))\n\n# extract the individual arrays of X, Y, and Z values\nX_new = XYZ_new[:, 0]\nY_new = XYZ_new[:, 1]\nZ_new = XYZ_new[:, 2]\n\n\n\n\nCode\nfig, ax = plt.subplots(figsize=(18, 8), nrows=1, ncols=2)\n\nax[0].plot(X[:10000], Z[:10000], c='#FF7000', lw=3, alpha=0.5)\nax[0].plot(X_new[:10000], Z_new[:10000], c='#10A19D', lw=3, alpha=0.5)\n\nax[1].plot(X[:25000], Z[:25000], c='#FF7000', lw=3, alpha=0.5)\nax[1].plot(X_new[:25000], Z_new[:25000], c='#10A19D', lw=3, alpha=0.5)"
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html#the-west-and-the-east",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html#the-west-and-the-east",
    "title": "A chaotic butterfly",
    "section": "The West and The East",
    "text": "The West and The East"
  },
  {
    "objectID": "blog/01_lorenz_attractor/lorenz_attractor.html#references",
    "href": "blog/01_lorenz_attractor/lorenz_attractor.html#references",
    "title": "A chaotic butterfly",
    "section": "References",
    "text": "References\nI‚Äôve learned to demonstrate (computationally) the Lorenz system from the following work:\n\nhttps://geoffboeing.com/2016/12/animating-lorenz-attractor-python/\nhttps://fromsystosys.netlify.app/2018/07/28/lorenz-attractor-animation-plotly/\n\nOther pieces of introductory articles about strange attractors, the Butterfly effect, and fractals\n\nhttps://fractalfoundation.org/OFC/OFC-7-1.html/\nhttps://hypertextbook.com/chaos/strange/"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Si-Nguyen Mai",
    "section": "",
    "text": "Hi üëã, I am Si-Nguyen Mai. My original full name is Mai Thu Sƒ© Nguy√™n. I‚Äôm from Vietnam in the Far East. I was born in the bustle Ho Chi Minh City, which is also known as Saigon, or the ‚ÄúPearl of the Far East‚Äù.\nSo far, my intellectual path has crossed here and there. I got my BEng degree in Biomedical Engineering in Ho Chi Minh City, and then my MSc in Ecology & Evolution in Groningen, the Netherlands. During my Master‚Äôs, I also spent a few months in the UK for a research project. Now, I‚Äôm back in Ho Chi Minh City again, continuing my enthusiasm for science, especially science about microbes.\nMy current position is a Research Assistant at the Molecular Epidemiology Group at OUCRU Vietnam. In my work, I‚Äôm spending my time playing with bacterial genomic data, thinking and discussing about pathogenic microbes, paricularly their genetic profiles and their journeys in life.\nMy scientific interests are broad and dynamic, but over the past few years and probably more to come, I have just been sticking to the world of microbes, ecology, evolution, and health. I‚Äôm also specifically attracted to complex systems with inter-dependent relationships and emergent behaviours, such as host-microbiome systems. While studying these abstract concepts, I enjoy coding, learning and applying tech, analysing data, and modelling."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Si Nguyen‚Äôs Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nA chaotic butterfly\n\n\n\n\n\n\n\nModelling\n\n\nPython\n\n\n\n\nAn elegant model of dynamical system. Dynamics in shape of a butterfly. Chaos, determinism, and predictibility.\n\n\n\n\n\n\nNov 1, 2022\n\n\n7 min\n\n\n\n\n\n\nNo matching items"
  }
]